<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hell's Gate — Web RPG (Logged In)</title>
<style>
:root{
  --bg:#071019; --panel:#0f1720; --accent:#e14b3b; --muted:#9fb0c8;
  --grass1:#2e7d32; --grass2:#287a3a; --dirt:#6d4c41; --wood:#8b5a2b;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#021018);color:#e6f2fb;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
.app{display:flex;flex-direction:column;height:100vh;padding:12px;gap:10px}
.header{display:flex;justify-content:space-between;align-items:center}
.brand{font-weight:800;letter-spacing:0.6px}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;color:inherit;cursor:pointer}
.userChip{display:flex;gap:8px;align-items:center}
.userChip img{width:36px;height:36px;border-radius:50%}
.layout{display:flex;gap:12px;flex:1;min-height:0}
.left{flex:1;display:flex;flex-direction:column;gap:10px}
.canvas-wrap{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(0,0,0,0.6);min-height:0}
canvas{width:100%;height:calc(100vh - 260px);display:block;border-radius:10px;background:transparent}
.right{width:360px;display:flex;flex-direction:column;gap:10px;min-width:240px}
.panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
.row{display:flex;justify-content:space-between;align-items:center}
.small{font-size:13px;color:var(--muted)}
.log{height:160px;overflow:auto;font-family:monospace;background:transparent;padding:8px;border-radius:6px}
.inventory{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
.item{background:rgba(255,255,255,0.02);padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:70px;text-align:center;font-size:13px}
.controls-touch{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:40}
.touch-btn{width:64px;height:64px;border-radius:10px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.03);font-weight:700}
.footer{font-size:12px;color:var(--muted);text-align:center;padding-top:6px}

/* Game Over overlay */
#gameOverOverlay{
  position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:1000;
  background:linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.6));
  color:white; font-size:20px; flex-direction:column;
}
#gameOverOverlay .box{background:rgba(10,10,10,0.9); padding:22px; border-radius:12px; border:1px solid rgba(255,255,255,0.06); text-align:center}
a.linkBtn{display:inline-block;margin-top:12px;padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);text-decoration:none;color:white}
@media(max-width:900px){
  canvas{height:44vh}
  .layout{flex-direction:column}
  .right{width:100%}
  .controls{justify-content:flex-start}
  .controls-touch{right:12px;bottom:12px}
}
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="brand">Hell's Gate — Web RPG (Online)</div>
    <div class="controls">
      <div id="userArea" class="userChip small"><img id="userPic" src="" alt="" style="display:none"><span id="userName">Guest</span></div>
      <button id="btnSignOut" class="btn">Sign out</button>
      <button id="saveCloud" class="btn">Save to Cloud</button>
      <button id="loadCloud" class="btn">Load from Cloud</button>
    </div>
  </div>

  <div class="layout">
    <div class="left">
      <div class="canvas-wrap panel">
        <canvas id="game" width="1280" height="720"></canvas>
      </div>

      <div class="panel">
        <div class="row">
          <div style="font-weight:700">World Log</div>
          <div class="small" id="levelInfo">Level 1 • Layer 1/5</div>
        </div>
        <div id="log" class="log"></div>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div class="row">
          <div style="font-weight:700">Player</div>
          <div class="small" id="playerId">Local</div>
        </div>
        <div class="row"><div>Level</div><div id="playerLevel">1</div></div>
        <div class="row"><div>HP</div><div id="hpText">100/100</div></div>
        <div style="height:10px;background:#162224;border-radius:6px;overflow:hidden;margin-top:6px">
          <div id="hpBar" style="height:100%;background:linear-gradient(90deg,#ff7b7b,#ff3b3b);width:100%"></div>
        </div>
        <div class="row"><div>Attack</div><div id="atkText">8</div></div>
        <div class="row"><div>Magic</div><div id="magText">4</div></div>
        <div class="row"><div>Speed</div><div id="spdText">140</div></div>
        <div class="row"><div>XP</div><div id="xpText">0/100</div></div>
        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="attackLightBtn" class="btn">Light</button>
          <button id="attackHeavyBtn" class="btn">Heavy</button>
          <button id="attackMagicBtn" class="btn">Magic</button>
          <button id="attackComboBtn" class="btn">Combo</button>
        </div>
      </div>

      <div id="statusPanel" class="panel" style="display:none">
        <div style="font-weight:700">Status & Allocate Points</div>
        <div class="small">Unspent: <span id="statPoints">0</span></div>
        <div style="margin-top:8px">
          <div class="row"><div>STR</div><div id="statStr">1</div></div>
          <div class="row"><div>MAG</div><div id="statMag">1</div></div>
          <div class="row"><div>DEF</div><div id="statDef">1</div></div>
          <div class="row"><div>SPD</div><div id="statSpd">1</div></div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="addStr" class="btn">+STR</button>
            <button id="addMag" class="btn">+MAG</button>
            <button id="addDef" class="btn">+DEF</button>
            <button id="addSpd" class="btn">+SPD</button>
          </div>
        </div>
      </div>

      <div id="inventoryPanel" class="panel" style="display:none">
        <div style="font-weight:700">Inventory</div>
        <div class="inventory" id="inventoryList"></div>
      </div>

      <div id="storePanel" class="panel" style="display:none">
        <div style="font-weight:700">Store</div>
        <div class="small">Gold: <span id="goldText">0</span></div>
        <div id="storeItems" style="margin-top:8px;display:flex;flex-direction:column;gap:8px"></div>
      </div>
    </div>
  </div>

  <div class="footer small">Logged-in mode. Your progress will be saved to your Google account (Realtime DB) when you press Save to Cloud.</div>
</div>

<!-- Game Over overlay -->
<div id="gameOverOverlay"><div class="box"><div id="gameOverText">You died — Game Over</div><a class="linkBtn" id="goHome">Return to Login</a></div></div>

<!-- Firebase compat SDKs (matching login.html) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<script>
/*
  game.html — connected to Firebase Auth & Realtime DB (compat)
  - Requires the user to be signed in (redirects to login.html if not)
  - Loads /users/{uid}/save into the game state
  - Save to cloud writes to /users/{uid}/save
  - Sign out returns to login.html
*/

// ---------- Firebase config (provided) ----------
const firebaseConfig = {
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  apiKey: "AIzaSyBF-h6Ka-jU8Cd3xpaHTT-UtNBO3aDQWZU",
  authDomain: "rpg-game-ff3f9.firebaseapp.com",
  databaseURL: "https://rpg-game-ff3f9-default-rtdb.firebaseio.com",
  projectId: "rpg-game-ff3f9",
  storageBucket: "rpg-game-ff3f9.firebasestorage.app",
  messagingSenderId: "212932693152",
  appId: "1:212932693152:web:dbdeef096a87a7c1de0dc5",
  measurementId: "G-JLX6YH0YFY"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const rtdb = firebase.database();

// ---------- Auth check & UI ----------
const userNameEl = document.getElementById('userName');
const userPicEl = document.getElementById('userPic');
const btnSignOut = document.getElementById('btnSignOut');
btnSignOut.onclick = ()=>{ auth.signOut().then(()=>{ window.location.href = 'login.html'; }); };

auth.onAuthStateChanged(async (user)=>{
  if(!user){ // not signed in -> redirect to login
    window.location.href = 'login.html';
    return;
  }
  // signed in: show profile
  userNameEl.textContent = user.displayName || 'Player';
  if(user.photoURL){ userPicEl.src = user.photoURL; userPicEl.style.display = ''; } else userPicEl.style.display = 'none';
  document.getElementById('playerId').textContent = user.uid.slice(0,8);
  // load saved data
  await loadFromCloud();
});

// ---------- Game code (adapted from previous full game) ----------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
function resizeCanvas(){ const ratio=W/H; const maxW=Math.min(window.innerWidth-40,1400); let newW=Math.min(maxW,W); let newH=Math.floor(newW/ratio); if(window.innerWidth<900){ newW=window.innerWidth-32; newH=Math.floor(newW/ratio);} canvas.style.width=newW+'px'; canvas.style.height=newH+'px'; }
window.addEventListener('resize', resizeCanvas); resizeCanvas();

const rand = (a,b)=> Math.random()*(b-a)+a;
const clamp = (v,a,b)=> Math.max(a,Math.min(b,v));
const now = ()=> performance.now();
function formatTime(){ return new Date().toLocaleTimeString(); }
function log(msg){ const el=document.getElementById('log'); const d=document.createElement('div'); d.textContent=`[${formatTime()}] ${msg}`; el.prepend(d); if(el.childNodes.length>400) el.removeChild(el.lastChild); }

// Game state
const MAX_LEVEL = 100;
let currentLevel = 1;
let currentLayer = 1;
function layersFor(level){ return 5 + (level - 1); }

const player = {
  x: W/2, y: H/2, w:28, h:36,
  hp:100, maxHp:100, atk:8, mag:4, spd:140,
  lvl:1, xp:0, gold:0, statPoints:0,
  stats:{str:1,mag:1,def:1,spd:1},
  inventory:[], equip:{weapon:null,armor:null,artifact:null},
  mode:'sword', // 'sword' | 'magic'
  facing:{x:0,y:-1}
};

let worldObjects = [];
let enemies = [];
let projectiles = [];
let attackFX = [];
let lastTick = now();
let lastSpawn = 0;
let localUser = null; // Firebase user

// store items
const STORE_ITEMS = [
  { id:'sword_bronze', name:'Bronze Sword', type:'weapon', atk:4, mag:0, price:60 },
  { id:'staff_wood', name:'Novice Staff', type:'weapon', atk:0, mag:5, price:70 },
  { id:'armor_leather', name:'Leather Armor', type:'armor', def:3, price:90 },
  { id:'artifact_ring', name:'Ring of Fortune', type:'artifact', price:150, bonus:{goldMult:1.05} }
];

// Procedural generation
function generateWorld(layer){
  worldObjects = [];
  const density = clamp(5 + Math.floor(layer/2), 5, 24);
  for(let i=0;i<density;i++){
    const x = rand(40, W-80), y = rand(40, H-120);
    const r = Math.random();
    if(r < 0.55) worldObjects.push({type:'tree', x,y, size:rand(18,40)});
    else if(r < 0.8) worldObjects.push({type:'rock', x,y, size:rand(10,20)});
    else worldObjects.push({type:'house', x,y, w:rand(36,80), h:rand(24,46)});
  }
}

// Drawing helpers
function drawGround(){ const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#163e1f'); g.addColorStop(1,'#0f2b16'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); for(let i=0;i<160;i++){const x=(i*97)%W,y=(i*43)%H;ctx.fillStyle=(i%2? '#2e7d32':'#287a3a');ctx.fillRect(x,y+20,2,6+(i%3));}}
function drawTree(t){ ctx.fillStyle='#6b3f22'; ctx.fillRect(t.x-(t.size/6), t.y, t.size/3, t.size*0.9); ctx.fillStyle='#1f7a2a'; ctx.beginPath(); ctx.ellipse(t.x, t.y - t.size*0.2, t.size*0.9, t.size, 0,0,Math.PI*2); ctx.fill(); }
function drawRock(r){ ctx.fillStyle='#6b6b6b'; ctx.beginPath(); ctx.ellipse(r.x, r.y, r.size, r.size*0.7, 0,0,Math.PI*2); ctx.fill(); }
function drawHouse(h){ ctx.fillStyle='#8b5a2b'; ctx.fillRect(h.x - h.w/2, h.y, h.w, h.h); ctx.fillStyle='#4a2b1b'; ctx.beginPath(); ctx.moveTo(h.x - h.w/2 - 2, h.y); ctx.lineTo(h.x, h.y - h.h*0.8); ctx.lineTo(h.x + h.w/2 + 2, h.y); ctx.fill(); ctx.fillStyle='#3b2418'; ctx.fillRect(h.x - 12, h.y + h.h - 16, 24, 16); }
function roundRect(ctx,x,y,w,h,r,fill){ if(typeof r==='undefined') r=6; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); }
function drawPlayer(){ ctx.save(); ctx.translate(player.x, player.y); ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(0, player.h/2 + 6, player.w*0.6, player.h*0.25, 0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#ff7b7b'; roundRect(ctx, -player.w/2, -player.h/2, player.w, player.h, 6, true); ctx.fillStyle='#ffd57a'; ctx.fillRect(-player.w/4, -player.h/2 - 10, player.w/2, 8); if(player.mode==='sword'){ ctx.fillStyle='#c9b27a'; ctx.fillRect(player.w/2, -6, 10, 14);} else { ctx.fillStyle='#8ad8ff'; ctx.beginPath(); ctx.arc(0, -player.h/2 - 12, 8, 0, Math.PI*2); ctx.fill(); } ctx.restore(); }
function drawEnemy(e){ ctx.save(); ctx.translate(e.x,e.y); ctx.fillStyle = e.isBoss ? '#ffb86b' : (e.lvl >= player.lvl ? '#ff6b6b' : '#7bd389'); roundRect(ctx, -e.w/2, -e.h/2, e.w, e.h, 6, true); ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(-e.w/2, e.h/2+6, e.w, 6); ctx.fillStyle='#ff7b7b'; const pct = Math.max(0,e.hp / e.maxHp); ctx.fillRect(-e.w/2, e.h/2+6, e.w * pct, 6); ctx.restore(); }
function drawProjectile(p){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle='rgba(120,200,255,0.95)'; ctx.fill(); }
function drawAttackFX(fx){ if(fx.type==='slash'){ ctx.save(); ctx.globalAlpha=fx.alpha; ctx.strokeStyle='rgba(255,230,160,0.95)'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(fx.x,fx.y,fx.r,fx.a1,fx.a2); ctx.stroke(); ctx.restore(); } else if(fx.type==='magicBurst'){ ctx.save(); ctx.globalAlpha=fx.alpha; ctx.fillStyle='rgba(120,200,255,0.22)'; ctx.beginPath(); ctx.arc(fx.x,fx.y,fx.r,0,Math.PI*2); ctx.fill(); ctx.restore(); } }

// ---------- Spawn & AI ----------
function spawnEnemy(layer, boss=false){
  const edge = Math.floor(rand(0,4));
  let x = rand(60, W-60), y = rand(60, H-140);
  if(edge===0){ x = rand(60, W-60); y = -40; }
  if(edge===1){ x = rand(60, W-60); y = H + 40; }
  if(edge===2){ x = -40; y = rand(60, H-60); }
  if(edge===3){ x = W + 40; y = rand(60, H-60); }
  const base = currentLevel + Math.floor(layer/5);
  const lvl = clamp(Math.floor(base + rand(-1,2)), 1, MAX_LEVEL);
  const size = boss?110:(20 + Math.floor(rand(8,26)));
  const hp = boss?Math.round(250 + lvl*120):Math.round(30 + lvl*12 + rand(0,30));
  const atk = boss?Math.round(20 + lvl*6):Math.round(3 + lvl*2);
  const spd = boss?18:(30 + lvl*4 + rand(0,30));
  enemies.push({x,y,w:size,h:size,hp,maxHp:hp,atk,spd,lvl,isBoss:boss,layer});
}
function enemyUpdate(e, dt){
  const dx = player.x - e.x, dy = player.y - e.y;
  const L = Math.hypot(dx,dy)||1;
  e.x += (dx/L) * (e.spd * dt);
  e.y += (dy/L) * (e.spd * dt);
  // collision with world objects: bounce out
  for(const obj of worldObjects){
    if(rectCircleCollision(obj, e.x, e.y, Math.max(e.w,e.h)/2)){
      const pushX = e.x - (obj.x || 0), pushY = e.y - (obj.y || 0);
      const mag = Math.hypot(pushX,pushY)||1;
      e.x += (pushX/mag) * 12 * dt; e.y += (pushY/mag) * 12 * dt;
    }
  }
  // collision player
  if(circleCollision(e.x,e.y,Math.max(e.w,e.h)/2, player.x,player.y,Math.max(player.w,player.h)/2)){
    if(!e._lastHit || now() - e._lastHit > 700){
      const dmg = Math.max(1, e.atk - (player.stats.def || 0));
      player.hp -= dmg; e._lastHit = now();
      log(`You were hit for ${dmg} HP.`);
      if(player.hp <= 0) handleGameOver();
    }
  }
}

// ---------- Combat ----------
function playerMelee(kind='light'){
  // light / heavy difference
  const base = kind==='light' ? Math.round(player.atk + player.stats.str*2) : Math.round(player.atk*1.7 + player.stats.str*3);
  // swing fx
  const angle = Math.atan2(player.facing.y, player.facing.x);
  const fx = { type:'slash', x: player.x + player.facing.x*22, y: player.y + player.facing.y*18, r: 46, a1: angle-1.0, a2: angle+1.0, alpha:1, ttl:260 };
  attackFX.push(fx);
  // damage enemies in range
  for(const e of enemies.slice()){
    const d = Math.hypot(e.x - player.x, e.y - player.y);
    if(d < 56){
      e.hp -= base;
      log(`You ${kind}-hit ${e.isBoss?'Boss':'Mob'} for ${base}.`);
      if(e.hp <= 0) killEnemy(e);
    }
  }
}
function playerMagic(){
  const speed = 10;
  const px = player.x + player.facing.x*22, py = player.y + player.facing.y*18;
  const p = { x:px, y:py, vx: player.facing.x*speed, vy: player.facing.y*speed, r:10, dmg: Math.round(player.mag + player.stats.mag*2), ttl: 2600 };
  projectiles.push(p);
  attackFX.push({ type:'magicBurst', x:px, y:py, r:18, alpha:1, ttl:160 });
}
let comboQueue = []; // store combos by sequence of inputs
function attemptCombo(){
  // Example combo: light -> light -> heavy = spinning slash (aoe)
  // comboQueue holds last few attacks as strings: 'L' or 'H' or 'M'
  const seq = comboQueue.join('');
  if(seq.endsWith('LLH')){
    // spinning AOE
    attackFX.push({ type:'magicBurst', x:player.x, y:player.y, r:80, alpha:1, ttl:420 });
    for(const e of enemies.slice()){
      const d = Math.hypot(e.x-player.x, e.y-player.y);
      if(d < 90){
        const dmg = Math.round(player.atk*2.2 + player.stats.str*3);
        e.hp -= dmg; log(`Combo hit ${e.isBoss?'Boss':'Mob'} for ${dmg}.`);
        if(e.hp <= 0) killEnemy(e);
      }
    }
    comboQueue = []; // reset
  } else if(seq.endsWith('MHM')){ // magic-heavy-magic -> meteor small
    attackFX.push({ type:'magicBurst', x:player.x + player.facing.x*100, y:player.y + player.facing.y*100, r:60, alpha:1, ttl:420 });
    for(const e of enemies.slice()){
      const d = Math.hypot(e.x - (player.x + player.facing.x*100), e.y - (player.y + player.facing.y*100));
      if(d < 80){ const dmg = Math.round(player.mag*3 + player.stats.mag*4); e.hp -= dmg; log(`Combo magic hit ${dmg}.`); if(e.hp<=0) killEnemy(e); }
    }
    comboQueue = [];
  }
  // keep queue short
  if(comboQueue.length > 6) comboQueue.shift();
}

function killEnemy(e){
  const idx = enemies.indexOf(e);
  if(idx>=0) enemies.splice(idx,1);
  const xpGain = Math.round(12 + e.lvl*8 + (e.isBoss?400:0));
  player.xp += xpGain; player.gold += Math.round(6 + e.lvl*3 + (e.isBoss?60:0));
  log(`Enemy defeated! +${xpGain} XP.`);
  if(e.isBoss){ log('Boss slain — layer cleared'); currentLayer = layersFor(currentLevel) + 1; }
  checkLevelUp();
}

// ---------- Projectiles & FX update ----------
function projectilesUpdate(dt){
  for(const p of projectiles.slice()){
    p.x += p.vx * dt * 60; p.y += p.vy * dt * 60; p.ttl -= dt*1000;
    for(const e of enemies.slice()){
      if(circleCollision(p.x,p.y,p.r,e.x,e.y,Math.max(e.w,e.h)/2)){
        e.hp -= p.dmg; p.ttl = -1; attackFX.push({ type:'magicBurst', x:p.x, y:p.y, r:24, alpha:1, ttl:180 }); log(`Magic hit for ${p.dmg}.`); if(e.hp<=0) killEnemy(e);
      }
    }
    for(const obj of worldObjects) if(rectCircleCollision(obj, p.x, p.y, p.r)){ p.ttl=-1; attackFX.push({type:'magicBurst', x:p.x, y:p.y, r:18, alpha:1, ttl:140}); }
  }
  projectiles = projectiles.filter(p=>p.ttl>0);
}
function attackFXUpdate(dt){ for(const fx of attackFX.slice()){ fx.ttl -= dt*1000; fx.alpha = Math.max(0, fx.ttl / 260); if(fx.ttl <= 0) attackFX.splice(attackFX.indexOf(fx),1); } }

// ---------- Collision helpers ----------
function circleCollision(x1,y1,r1,x2,y2,r2){ return (Math.hypot(x2-x1,y2-y1) <= (r1 + r2)); }
function rectCircleCollision(rect, cx, cy, cr){
  let rx = rect.x - (rect.w||0)/2 || rect.x;
  let ry = rect.y - (rect.h||0)/2 || rect.y;
  if(rect.type === 'tree' || rect.type === 'rock'){ rx = rect.x - (rect.size||0)/2; ry = rect.y - (rect.size||0)/2; }
  const closestX = clamp(cx, rx, rx + (rect.w || rect.size || 0));
  const closestY = clamp(cy, ry, ry + (rect.h || rect.size || 0));
  const dx = cx - closestX, dy = cy - closestY;
  return (dx*dx + dy*dy) <= cr*cr;
}

// ---------- Player death / game over ----------
function handleGameOver(){
  document.getElementById('gameOverOverlay').style.display = 'flex';
  document.getElementById('gameOverText').textContent = 'You died — Game Over';
  // allow user to return to login
  document.getElementById('goHome').onclick = ()=>{ auth.signOut().then(()=>{ window.location.href = 'login.html'; }); };
}

// ---------- Input handling ----------
let keys = {}; window.addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key===' '){ e.preventDefault(); playerMelee('light'); comboQueue.push('L'); attemptCombo(); } if(e.key.toLowerCase()==='q'){ toggleMode(); } if(e.key==='Enter'){ playerMelee('heavy'); comboQueue.push('H'); attemptCombo(); } if(e.key.toLowerCase()==='m'){ playerMagic(); comboQueue.push('M'); attemptCombo(); } }); window.addEventListener('keyup', e=>{ keys[e.key]=false; });

canvas.addEventListener('click', e=>{
  const rect = canvas.getBoundingClientRect();
  const cx = (e.clientX - rect.left) * (W / rect.width);
  const cy = (e.clientY - rect.top) * (H / rect.height);
  const dx = cx - player.x, dy = cy - player.y; const L = Math.hypot(dx,dy)||1;
  player.facing.x = dx/L; player.facing.y = dy/L;
  if(player.mode==='sword'){ playerMelee('light'); comboQueue.push('L'); attemptCombo(); } else { playerMagic(); comboQueue.push('M'); attemptCombo(); }
});

// touch move / tap attack
canvas.addEventListener('touchstart', (ev)=>{
  const t = ev.touches[0]; const rect = canvas.getBoundingClientRect();
  const x = (t.clientX - rect.left) * (W / rect.width), y = (t.clientY - rect.top) * (H / rect.height);
  touchTarget = { x,y, t: now() };
  setTimeout(()=>{ if(touchTarget && (now() - touchTarget.t < 220)){ const dx = touchTarget.x - player.x, dy = touchTarget.y - player.y; const L = Math.hypot(dx,dy)||1; player.facing.x = dx/L; player.facing.y = dy/L; if(player.mode==='sword'){ playerMelee('light'); comboQueue.push('L'); attemptCombo(); } else { playerMagic(); comboQueue.push('M'); attemptCombo(); } } }, 180);
});
canvas.addEventListener('touchmove', (ev)=>{ const t = ev.touches[0]; const rect = canvas.getBoundingClientRect(); const x=(t.clientX-rect.left)*(W/rect.width), y=(t.clientY-rect.top)*(H/rect.height); touchTarget={x,y,t:now()};});
canvas.addEventListener('touchend', ()=>{ touchTarget=null; });

// UI buttons
document.getElementById('attackLightBtn').onclick = ()=>{ playerMelee('light'); comboQueue.push('L'); attemptCombo(); };
document.getElementById('attackHeavyBtn').onclick = ()=>{ playerMelee('heavy'); comboQueue.push('H'); attemptCombo(); };
document.getElementById('attackMagicBtn').onclick = ()=>{ playerMagic(); comboQueue.push('M'); attemptCombo(); };
document.getElementById('attackComboBtn').onclick = ()=>{ attemptCombo(); };
document.getElementById('switchMode').onclick = toggleMode;

// toggle mode
function toggleMode(){ player.mode = (player.mode==='sword') ? 'magic' : 'sword'; document.getElementById('modeText').textContent = player.mode.charAt(0).toUpperCase()+player.mode.slice(1); log('Switched to '+player.mode); }

// ---------- Store & Inventory UI ----------
function renderStore(){
  const root = document.getElementById('storeItems'); if(!root) return; root.innerHTML = '';
  STORE_ITEMS.forEach(it=>{
    const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center';
    const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:700">${it.name}</div><div class="small">${it.type} • ${it.price}g</div>`;
    const buy = document.createElement('button'); buy.className='btn'; buy.textContent='Buy';
    buy.onclick = ()=>{ if(player.gold >= it.price){ player.gold -= it.price; player.inventory.push(JSON.parse(JSON.stringify(it))); renderInventory(); refreshUI(); saveToCloud(); log('Bought '+it.name); } else alert('Not enough gold'); };
    row.appendChild(left); row.appendChild(buy); root.appendChild(row);
  });
}
function renderInventory(){
  const root = document.getElementById('inventoryList'); if(!root) return; root.innerHTML = '';
  player.inventory.forEach((it, idx)=>{
    const el = document.createElement('div'); el.className='item'; el.innerHTML = `${it.name}<div class="small">${it.type}</div>`;
    el.onclick = ()=>{ if(it.type==='weapon') player.equip.weapon = it; if(it.type==='armor') player.equip.armor = it; if(it.type==='artifact') player.equip.artifact = it; applyEquip(); refreshUI(); saveToCloud(); log('Equipped '+it.name); };
    el.oncontextmenu = (e)=>{ e.preventDefault(); if(confirm('Drop '+it.name+'?')){ player.inventory.splice(idx,1); renderInventory(); saveToCloud(); log('Dropped '+it.name); } };
    root.appendChild(el);
  });
}
function applyEquip(){ const wAtk = player.equip.weapon?.atk || 0; const wMag = player.equip.weapon?.mag || 0; const def = player.equip.armor?.def || 0; player.atk = 8 + wAtk; player.mag = 4 + wMag; player.stats.def = Math.max(1, (player.stats.def || 1) + def - (player.equip.armor?0:0)); }

// ---------- Save / Load to Firebase ----------
async function saveToCloud(){
  if(!auth.currentUser) { log('Not signed in - cannot save'); return; }
  const payload = {
    player:{
      x: player.x, y: player.y, hp: player.hp, maxHp: player.maxHp, atk: player.atk, mag: player.mag, spd: player.spd,
      lvl: player.lvl, xp: player.xp, gold: player.gold, statPoints: player.statPoints, stats: player.stats,
      inventory: player.inventory, equip: player.equip, mode: player.mode
    },
    world:{ currentLevel, currentLayer, enemies, worldObjects, ts: Date.now() }
  };
  try{
    await rtdb.ref('users/' + auth.currentUser.uid + '/save').set(payload);
    log('Saved to cloud.');
  }catch(err){ console.error(err); log('Cloud save failed.'); }
}

async function loadFromCloud(){
  if(!auth.currentUser) return;
  localUser = auth.currentUser;
  document.getElementById('userName').textContent = localUser.displayName || 'Player';
  if(localUser.photoURL){ document.getElementById('userPic').src = localUser.photoURL; document.getElementById('userPic').style.display=''; }
  try{
    const snap = await rtdb.ref('users/' + localUser.uid + '/save').once('value');
    const data = snap.val();
    if(!data){ // no save -> create default profile if absent
      await rtdb.ref('users/' + localUser.uid).update({ name: localUser.displayName, email: localUser.email || '', photo: localUser.photoURL || '', createdAt: Date.now() });
      // keep defaults
      generateWorld(currentLayer); for(let i=0;i<4;i++) spawnEnemy(1,false); renderStore(); refreshUI();
      log('No cloud save found. Using fresh game.');
      return;
    }
    // merge loaded player
    const p = data.player || {};
    Object.assign(player, {
      x: p.x ?? player.x,
      y: p.y ?? player.y,
      hp: p.hp ?? player.hp,
      maxHp: p.maxHp ?? player.maxHp,
      atk: p.atk ?? player.atk,
      mag: p.mag ?? player.mag,
      spd: p.spd ?? player.spd,
      lvl: p.lvl ?? player.lvl,
      xp: p.xp ?? player.xp,
      gold: p.gold ?? player.gold,
      statPoints: p.statPoints ?? player.statPoints,
      stats: p.stats ?? player.stats,
      inventory: p.inventory ?? player.inventory,
      equip: p.equip ?? player.equip,
      mode: p.mode ?? player.mode
    });
    // world
    currentLevel = data.world?.currentLevel ?? currentLevel;
    currentLayer = data.world?.currentLayer ?? currentLayer;
    enemies = data.world?.enemies ?? enemies;
    worldObjects = data.world?.worldObjects ?? worldObjects;
    applyEquip(); renderInventory(); renderStore(); refreshUI(); log('Loaded cloud save.');
  }catch(err){ console.error(err); log('Failed to load cloud save.'); }
}

// ---------- Game over handling ----------
document.getElementById('goHome').onclick = ()=>{ auth.signOut().then(()=>{ window.location.href = 'login.html'; }); };

// ---------- Main update & draw ----------
function update(dt){
  let mvx=0,mvy=0;
  if(keys['w']||keys['ArrowUp']) mvy -=1;
  if(keys['s']||keys['ArrowDown']) mvy +=1;
  if(keys['a']||keys['ArrowLeft']) mvx -=1;
  if(keys['d']||keys['ArrowRight']) mvx +=1;
  if(touchTarget){ const dx=touchTarget.x-player.x, dy=touchTarget.y-player.y; const L=Math.hypot(dx,dy)||1; player.x += (dx/L) * player.spd * dt; player.y += (dy/L) * player.spd * dt; } else { const len=Math.hypot(mvx,mvy)||1; if(mvx||mvy){ player.x += (mvx/len)*player.spd*dt; player.y += (mvy/len)*player.spd*dt; lastFacing.x = mvx/len; lastFacing.y = mvy/len; player.facing = {...lastFacing}; } }
  // collisions with objects (player)
  for(const obj of worldObjects){
    if(obj.type==='tree' || obj.type==='rock'){
      const rx = obj.x, ry = obj.y, rr = (obj.size/2) + Math.max(player.w,player.h)/2;
      if(Math.hypot(player.x - rx, player.y - ry) < rr){
        const dx = player.x - rx, dy = player.y - ry; const L=Math.hypot(dx,dy)||1;
        player.x = rx + (dx/L) * rr; player.y = ry + (dy/L) * rr;
      }
    } else if(obj.type==='house'){
      const rx = obj.x - obj.w/2, ry = obj.y, rw = obj.w, rh = obj.h;
      const closestX = clamp(player.x, rx, rx+rw); const closestY = clamp(player.y, ry, ry+rh);
      const dx = player.x - closestX, dy = player.y - closestY;
      if(dx*dx + dy*dy < Math.pow(Math.max(player.w,player.h)/2,2)){
        const pushX = dx||1, pushY = dy||1; const L=Math.hypot(pushX,pushY)||1;
        player.x += (pushX/L)*6; player.y += (pushY/L)*6;
      }
    }
  }
  // projectiles & fx
  projectilesUpdate(dt); attackFXUpdate(dt);
  // enemies update
  for(const e of enemies.slice()) enemyUpdate(e, dt);
  // spawn logic
  lastSpawn += dt;
  const spawnInterval = Math.max(0.6, 2.5 - currentLevel*0.02);
  if(lastSpawn > spawnInterval){
    const cap = clamp(4 + Math.floor(currentLevel/3) + Math.floor(currentLayer/2), 6, 24);
    if(enemies.length < cap) spawnEnemy(currentLayer, false);
    lastSpawn = 0;
  }
  // progression & boss spawn logic
  if(enemies.length === 0){
    currentLayer++;
    if(currentLayer > layersFor(currentLevel)){
      spawnEnemy(currentLayer, true);
      log('Boss spawned for level ' + currentLevel);
    } else {
      generateWorld(currentLayer);
      log('Entering layer '+currentLayer);
    }
    document.getElementById('levelInfo').textContent = `Level ${currentLevel} • Layer ${currentLayer}/${layersFor(currentLevel)}`;
  }
  if(currentLayer > layersFor(currentLevel)){
    currentLevel = Math.min(MAX_LEVEL, currentLevel + 1);
    currentLayer = 1;
    generateWorld(currentLayer);
    log('Advanced to Level ' + currentLevel);
    player.gold += 50 + Math.floor(currentLevel*8);
    document.getElementById('levelInfo').textContent = `Level ${currentLevel} • Layer ${currentLayer}/${layersFor(currentLevel)}`;
  }
  checkLevelUp();
}
function draw(){
  drawGround();
  for(const obj of worldObjects){ if(obj.type==='tree') drawTree(obj); else if(obj.type==='rock') drawRock(obj); else if(obj.type==='house') drawHouse(obj); }
  for(const e of enemies) drawEnemy(e);
  drawPlayer(); for(const p of projectiles) drawProjectile(p); for(const fx of attackFX) drawAttackFX(fx);
}
function gameLoop(ts){
  const dt = Math.min(0.05, (ts - lastTick)/1000);
  update(dt); draw(); lastTick = ts; requestAnimationFrame(gameLoop);
}

// ---------- UI & helpers ----------
function refreshUI(){
  document.getElementById('hpText').textContent = `${Math.round(player.hp)}/${player.maxHp}`;
  document.getElementById('hpBar').style.width = `${Math.max(0,(player.hp/player.maxHp)*100)}%`;
  const equipAtk = player.equip.weapon?.atk || 0; const equipMag = player.equip.weapon?.mag || 0;
  document.getElementById('atkText').textContent = player.atk + equipAtk;
  document.getElementById('magText').textContent = player.mag + equipMag;
  document.getElementById('spdText').textContent = Math.round(player.spd + player.stats.spd * 4);
  const xpForNext = 100 + (player.lvl - 1)*60;
  document.getElementById('xpText').textContent = `${Math.round(player.xp)}/${xpForNext}`;
  document.getElementById('playerLevel').textContent = player.lvl;
  document.getElementById('goldText').textContent = player.gold;
  document.getElementById('statPoints').textContent = player.statPoints;
  document.getElementById('statStr').textContent = player.stats.str;
  document.getElementById('statMag').textContent = player.stats.mag;
  document.getElementById('statDef').textContent = player.stats.def;
  document.getElementById('statSpd').textContent = player.stats.spd;
  renderInventory(); renderStore();
}

// ---------- Init ----------
function initLocal(){
  applyEquip(); generateWorld(currentLayer);
  for(let i=0;i<4;i++) spawnEnemy(1,false);
  renderStore(); renderInventory(); refreshUI();
  if(window.innerWidth < 800) {/* show touch controls if implemented */ }
  requestAnimationFrame(gameLoop);
}
initLocal();
setInterval(()=>{ refreshUI(); }, 700);

// ---------- Cloud save/load buttons ----------
document.getElementById('saveCloud').onclick = ()=>{ saveToCloud(); };
document.getElementById('loadCloud').onclick = ()=>{ loadFromCloud(); };

// ---------- End of script ----------
</script>
</body>
</html>
